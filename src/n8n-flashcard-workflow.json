{
  "name": "My workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-flashcards",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "d172bc46-aef1-4086-9643-f7cb072d4fb5",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -1900,
        -60
      ],
      "webhookId": "cognify-flashcards"
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "transcript",
              "value": "={{ $json.body.transcript }}"
            },
            {
              "name": "sessionId",
              "value": "={{ $json.body.sessionId || 'default' }}"
            }
          ],
          "number": [
            {
              "name": "iteration",
              "value": 1
            },
            {
              "name": "maxIterations",
              "value": 4
            }
          ]
        },
        "options": {}
      },
      "id": "660f2f10-7d4a-4015-a94c-64e3cb9303be",
      "name": "Initialize Variables",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        -1700,
        -60
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4.1-mini",
        "prompt": {
          "messages": [
            {
              "content": "=You are an expert educational content analyzer. Your task is to extract and organize the most important concepts from educational content.  Analyze the provided transcript and create a detailed, structured list of important concepts that would be valuable for students to learn and remember.  For each concept, provide: 1. **Concept Name**: Clear, concise title 2. **Category**: Type of concept (definition, process, principle, formula, example, etc.) 3. **Importance Level**: High, Medium, or Low 4. **Description**: 2-3 sentence explanation of why this concept matters 5. **Key Details**: Specific facts, steps, or components to remember  Return ONLY a JSON array in this exact format: [   {     \"name\": \"Machine Learning Definition\",     \"category\": \"definition\",     \"importance\": \"High\",     \"description\": \"Fundamental concept that defines the entire field. Students must understand this core definition to grasp all subsequent topics.\",     \"keyDetails\": [\"Subset of AI\", \"Learns from data without explicit programming\", \"Improves performance through experience\"]   },   {     \"name\": \"Supervised Learning Process\",     \"category\": \"process\",     \"importance\": \"High\",      \"description\": \"Core methodology that forms the foundation of most practical ML applications. Understanding this process is essential for implementation.\",     \"keyDetails\": [\"Uses labeled training data\", \"Learns input-output relationships\", \"Makes predictions on new data\"]   } ]  Extract 8-15 concepts from this transcript, but generate more if needed. Focus on concepts that would make excellent flashcard material.  Transcript to analyze: {{ $node[\"Initialize Variables\"].json[\"transcript\"] }}"
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "id": "7e79923b-3ff8-48cb-8f67-971a803958ba",
      "name": "Extract Concepts",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        -1500,
        -60
      ],
      "credentials": {
        "openAiApi": {
          "id": "KDqofqWJzHWJ0pPy",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse and validate extracted concepts from AI response\nlet response;\ntry {\n  const input = $input.first().json;\n  \n  // Handle the actual structure of your input\n  if (Array.isArray(input) && input[0] && input[0].message && input[0].message.content) {\n    response = input[0].message.content;\n  } else if (input.choices && input[0] && input[0].message) {\n    response = input[0].message.content;\n  } else if (input.choices && input[0] && input[0].text) {\n    response = input[0].text;\n  } else if (input.text) {\n    response = input.text;\n  } else if (input.message) {\n    response = input.message;\n  } else if (input.content) {\n    response = input.content;\n  } else {\n    response = JSON.stringify(input);\n  }\n} catch (e) {\n  response = 'Error accessing response';\n}\n\nconst sessionData = $node[\"Initialize Variables\"].json;\n\ntry {\n  // Ensure response is always a string before processing\n  if (typeof response !== 'string') {\n    response = JSON.stringify(response);\n  }\n  \n  // Handle null or undefined responses\n  if (!response || response === 'null' || response === 'undefined') {\n    throw new Error('Empty or invalid response from AI');\n  }\n  \n  console.log(`üîç Raw response preview: ${response.substring(0, 200)}...`);\n  \n  // Clean response and extract JSON with improved handling\n  let cleanResponse = response\n    .replace(/```json\\s*/g, '')  // Remove ```json with any whitespace  \n    .replace(/```\\s*/g, '')      // Remove ``` with any whitespace\n    .replace(/^json\\s*/g, '')    // Remove 'json' at start with whitespace\n    .trim();\n  \n  // Handle the specific escaped JSON format from your input\n  if (cleanResponse.startsWith('\"') && cleanResponse.endsWith('\"')) {\n    try {\n      // This is a JSON-encoded string, so parse it first to get the actual JSON\n      cleanResponse = JSON.parse(cleanResponse);\n    } catch (e) {\n      console.log(`‚ö†Ô∏è Failed to parse as JSON-encoded string: ${e.message}`);\n    }\n  }\n  \n  // Now handle any remaining escaped characters\n  if (typeof cleanResponse === 'string') {\n    cleanResponse = cleanResponse\n      .replace(/\\\\n/g, '\\n')\n      .replace(/\\\\\"/g, '\"')\n      .replace(/\\\\t/g, '\\t')\n      .replace(/\\\\r/g, '\\r')\n      .replace(/\\\\\\\\/g, '\\\\');\n  }\n  \n  console.log(`üîç Cleaned response preview: ${cleanResponse.substring(0, 200)}...`);\n  \n  // Try direct JSON parse first\n  let concepts;\n  try {\n    concepts = JSON.parse(cleanResponse);\n    console.log(`‚úÖ Successfully parsed JSON directly`);\n  } catch (e) {\n    console.log(`‚ö†Ô∏è Direct parse failed: ${e.message}`);\n    \n    // Fallback 1: extract JSON array from text more robustly with proper bracket matching\n    let jsonMatch = null;\n    let bracketCount = 0;\n    let startIndex = cleanResponse.indexOf('[');\n    \n    if (startIndex !== -1) {\n      for (let i = startIndex; i < cleanResponse.length; i++) {\n        if (cleanResponse[i] === '[') {\n          bracketCount++;\n        } else if (cleanResponse[i] === ']') {\n          bracketCount--;\n          if (bracketCount === 0) {\n            jsonMatch = cleanResponse.substring(startIndex, i + 1);\n            break;\n          }\n        }\n      }\n    }\n    \n    if (jsonMatch) {\n      try {\n        concepts = JSON.parse(jsonMatch);\n        console.log(`‚úÖ Successfully parsed JSON from bracket matching`);\n      } catch (parseError) {\n        console.log(`‚ö†Ô∏è Bracket matching parse failed: ${parseError.message}`);\n        \n        // Fallback 2: Try regex approach\n        const regexMatch = cleanResponse.match(/\\[[\\s\\S]*?\\]/);\n        if (regexMatch) {\n          try {\n            concepts = JSON.parse(regexMatch[0]);\n            console.log(`‚úÖ Successfully parsed JSON from regex match`);\n          } catch (regexError) {\n            console.log(`‚ö†Ô∏è Regex parse failed: ${regexError.message}`);\n            console.log(`‚ö†Ô∏è Problematic JSON snippet: ${regexMatch[0].substring(0, 500)}...`);\n            throw new Error(`Failed to parse extracted JSON: ${regexError.message}`);\n          }\n        } else {\n          throw new Error('No valid JSON array found in concepts response');\n        }\n      }\n    } else {\n      throw new Error('No valid JSON array found in concepts response');\n    }\n  }\n  \n  // Validate array structure\n  if (!Array.isArray(concepts)) {\n    console.log(`‚ùå Concepts is not an array. Type: ${typeof concepts}`);\n    console.log(`‚ùå Concepts value:`, concepts);\n    throw new Error('Concepts response is not an array');\n  }\n  \n  // Filter and validate concepts\n  const validConcepts = concepts.filter(concept => \n    concept && \n    typeof concept === 'object' &&\n    concept.name && \n    concept.category &&\n    concept.importance &&\n    concept.description &&\n    concept.keyDetails &&\n    typeof concept.name === 'string' && \n    typeof concept.category === 'string' &&\n    typeof concept.importance === 'string' &&\n    typeof concept.description === 'string' &&\n    Array.isArray(concept.keyDetails) &&\n    concept.name.trim().length > 3 &&\n    concept.description.trim().length > 10\n  );\n  \n  if (validConcepts.length === 0) {\n    throw new Error('No valid concepts found');\n  }\n  \n  // Organize concepts by importance\n  const highPriority = validConcepts.filter(c => c.importance.toLowerCase() === 'high');\n  const mediumPriority = validConcepts.filter(c => c.importance.toLowerCase() === 'medium');\n  const lowPriority = validConcepts.filter(c => c.importance.toLowerCase() === 'low');\n  \n  console.log(`‚úÖ Extracted ${validConcepts.length} concepts:`);\n  console.log(`   üìç High Priority: ${highPriority.length}`);\n  console.log(`   üìç Medium Priority: ${mediumPriority.length}`);\n  console.log(`   üìç Low Priority: ${lowPriority.length}`);\n  \n  // Create structured concept summary for flashcard generation\n  const conceptSummary = validConcepts.map(concept => \n    `**${concept.name}** (${concept.category}, ${concept.importance} priority)\\n` +\n    `Description: ${concept.description}\\n` +\n    `Key Details: ${concept.keyDetails.join(', ')}\\n`\n  ).join('\\n');\n  \n  return {\n    success: true,\n    concepts: validConcepts,\n    conceptCount: validConcepts.length,\n    conceptSummary: conceptSummary,\n    priorityBreakdown: {\n      high: highPriority.length,\n      medium: mediumPriority.length,\n      low: lowPriority.length\n    },\n    sessionId: sessionData.sessionId,\n    transcript: sessionData.transcript,\n    iteration: sessionData.iteration,\n    maxIterations: sessionData.maxIterations\n  };\n  \n} catch (error) {\n  console.error(`‚ùå CRITICAL: PARSE CONCEPTS FAILED - USING FALLBACK!`);\n  console.error(`‚ùå Error:`, error.message);\n  console.error(`‚ùå Raw AI Response:`, response);\n  console.error(`‚ùå Response Length:`, response?.length || 'undefined');\n  console.error(`‚ùå This means Extract Concepts AI call failed or returned invalid JSON!`);\n  \n  // Create fallback concepts\n  const fallbackConcepts = [\n    {\n      name: \"Main Topic Overview\",\n      category: \"definition\",\n      importance: \"High\",\n      description: \"Core subject matter discussed in this educational session.\",\n      keyDetails: [\"Primary focus of the content\", \"Foundation for understanding\", \"Essential background knowledge\"]\n    },\n    {\n      name: \"Key Learning Objectives\",\n      category: \"principle\",\n      importance: \"High\", \n      description: \"Important goals and outcomes students should achieve from this material.\",\n      keyDetails: [\"Learning targets\", \"Skill development\", \"Knowledge acquisition\"]\n    },\n    {\n      name: \"Practical Applications\",\n      category: \"example\",\n      importance: \"Medium\",\n      description: \"Real-world uses and implementations of the discussed concepts.\",\n      keyDetails: [\"Industry applications\", \"Problem-solving examples\", \"Use cases\"]\n    }\n  ];\n  \n  const fallbackSummary = fallbackConcepts.map(concept => \n    `**${concept.name}** (${concept.category}, ${concept.importance} priority)\\n` +\n    `Description: ${concept.description}\\n` +\n    `Key Details: ${concept.keyDetails.join(', ')}\\n`\n  ).join('\\n');\n  \n  return {\n    success: false,\n    error: error.message,\n    concepts: fallbackConcepts,\n    conceptCount: fallbackConcepts.length,\n    conceptSummary: fallbackSummary,\n    priorityBreakdown: { high: 2, medium: 1, low: 0 },\n    sessionId: sessionData.sessionId,\n    transcript: sessionData.transcript,\n    iteration: sessionData.iteration,\n    maxIterations: sessionData.maxIterations,\n    fallback: true\n  };\n}"
      },
      "id": "b7153ad9-19fe-4b2c-8e27-9ae522f6ad2b",
      "name": "Parse Concepts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -1300,
        -60
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4.1-mini",
        "prompt": {
          "messages": [
            {
              "content": "=You are an expert educational flashcard creator. Generate high-quality flashcards based on the provided concept analysis.  Flashcard Generation Guidelines: - Create 8-12 flashcards covering the most important concepts - Prioritize HIGH importance concepts, include some MEDIUM importance - Use varied question types: definitions, explanations, applications, comparisons - Make questions specific and clear - Provide comprehensive but concise answers - Ensure appropriate difficulty level for the content  For each concept, consider creating flashcards that test: 1. **Definition/Understanding**: \"What is...?\" \"Define...\" \"Explain...\" 2. **Application**: \"How would you use...?\" \"When should you apply...?\" 3. **Analysis**: \"What are the key differences between...?\" \"Why is this important?\" 4. **Synthesis**: \"How do these concepts relate?\" \"What would happen if...?\"  Return ONLY a valid JSON array of flashcards: [{\"question\": \"What is machine learning?\", \"answer\": \"Machine learning is a subset of artificial intelligence that enables computers to learn and improve from experience without being explicitly programmed. It uses data to identify patterns and make predictions or decisions.\"}, {\"question\": \"What are the three main types of machine learning?\", \"answer\": \"The three main types are: 1) Supervised learning (uses labeled data), 2) Unsupervised learning (finds patterns in unlabeled data), and 3) Reinforcement learning (learns through trial and error with rewards and penalties).\"}]  **EXTRACTED CONCEPTS TO USE:** {{ $node[\"Parse Concepts\"].json[\"conceptSummary\"] }}  **CONCEPT STATISTICS:** - Total Concepts: {{ $node[\"Parse Concepts\"].json[\"conceptCount\"] }} - High Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"high\"] }} - Medium Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"medium\"] }} - Low Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"low\"] }}  Generate flashcards that comprehensively cover these concepts, focusing on the high-priority items first."
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "id": "252a6408-1946-49bc-a791-4c455efd83e4",
      "name": "Generate Flashcards",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        -1100,
        -60
      ],
      "credentials": {
        "openAiApi": {
          "id": "KDqofqWJzHWJ0pPy",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === Helper: Try parse anything into JSON safely ===\nfunction tryParseJson(input) {\n  try {\n    return typeof input === 'string' ? JSON.parse(input) : input;\n  } catch (e) {\n    return null;\n  }\n}\n\n// === Step 1: Get raw AI response ===\nconst input = $input.first().json;\n\n// Handle the specific structure from your input\nlet rawContent = null;\n\n// Check if it's an array with message content\nif (Array.isArray(input) && input.length > 0) {\n  rawContent = input[0]?.message?.content;\n} else if (input?.choices?.[0]?.message?.content) {\n  // OpenAI format\n  rawContent = input.choices[0].message.content;\n} else if (input?.message?.content) {\n  // Direct message format\n  rawContent = input.message.content;\n} else if (typeof input === 'string') {\n  // Direct string\n  rawContent = input;\n} else {\n  // Fallback to stringify\n  rawContent = JSON.stringify(input);\n}\n\n// === Step 2: Parse the content string to extract flashcards ===\nlet flashcards = [];\n\nif (rawContent) {\n  // Clean up the content string\n  let cleaned = String(rawContent)\n    .replace(/```(?:json)?/gi, '')\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\\"/g, '\"')\n    .trim();\n\n  // Try to parse as JSON directly\n  let parsed = tryParseJson(cleaned);\n  \n  // If it's already an array, use it\n  if (Array.isArray(parsed)) {\n    flashcards = parsed;\n  } else if (parsed && typeof parsed === 'object') {\n    // If it's an object, look for array properties\n    const possibleArrays = Object.values(parsed).filter(Array.isArray);\n    if (possibleArrays.length > 0) {\n      flashcards = possibleArrays[0];\n    }\n  } else {\n    // Try to extract array from string using regex\n    const arrayMatch = cleaned.match(/\\[[\\s\\S]*\\]/);\n    if (arrayMatch) {\n      const arrayParsed = tryParseJson(arrayMatch[0]);\n      if (Array.isArray(arrayParsed)) {\n        flashcards = arrayParsed;\n      }\n    }\n  }\n}\n\n// === Step 3: Validate and filter flashcards ===\nconst validFlashcards = flashcards.filter(card =>\n  card &&\n  typeof card === 'object' &&\n  typeof card.question === 'string' &&\n  typeof card.answer === 'string' &&\n  card.question.trim().length >= 4 &&\n  card.answer.trim().length >= 8\n);\n\n// === Step 4: Get context from upstream node (with fallbacks) ===\nlet ctx = {};\ntry {\n  ctx = $node[\"Parse Concepts\"]?.json || {};\n} catch (e) {\n  // If Parse Concepts node doesn't exist, use defaults\n  ctx = {};\n}\n\n// Set default values if not available\nconst sessionId = ctx.sessionId || `session_${Date.now()}`;\nconst conceptCount = ctx.conceptCount || validFlashcards.length;\nconst priorityBreakdown = ctx.priorityBreakdown || { high: 0, medium: 0, low: 0 };\nconst iteration = ctx.iteration || 1;\nconst maxIterations = ctx.maxIterations || 5;\n\n// === Step 5: Return successful response ===\nif (validFlashcards.length > 0) {\n  return {\n    success: true,\n    flashcards: validFlashcards,\n    count: validFlashcards.length,\n    sessionId: sessionId,\n    conceptsUsed: conceptCount,\n    conceptBreakdown: priorityBreakdown,\n    needsImprovement: validFlashcards.length < 8 && iteration < maxIterations,\n    iteration: iteration,\n    maxIterations: maxIterations,\n    generationMethod: 'concept-based'\n  };\n}\n\n// === Step 6: Fallback if no valid cards found ===\nconst fallbackCards = [\n  {\n    question: \"What are the main concepts covered in this educational content?\",\n    answer: \"The content covers several important concepts including key definitions, processes, and practical applications relevant to the subject matter.\"\n  },\n  {\n    question: \"Why are these concepts important for students to understand?\",\n    answer: \"These concepts form the foundation of knowledge in this subject area and are essential for further learning and practical application.\"\n  },\n  {\n    question: \"How can students apply the knowledge from this session?\",\n    answer: \"Students can apply this knowledge through practice exercises, real-world problem solving, and by connecting these concepts to related topics.\"\n  }\n];\n\nreturn {\n  success: false,\n  flashcards: fallbackCards,\n  error: 'No valid flashcards found after filtering',\n  count: fallbackCards.length,\n  sessionId: sessionId,\n  conceptsUsed: conceptCount,\n  conceptBreakdown: priorityBreakdown,\n  needsImprovement: false,\n  iteration: iteration,\n  maxIterations: maxIterations,\n  fallback: true,\n  generationMethod: 'concept-based-fallback'\n};"
      },
      "id": "94cc8e8c-0262-4abe-a99b-19e170b58419",
      "name": "Parse Flashcards",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -980,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "// Smart function to select appropriate flashcard data for analysis\n// This handles the branch logic to avoid n8n's \"Referenced node is unexecuted\" error\n\nlet flashcardData;\nlet dataSource;\n\ntry {\n  // First, try to get data from Parse Improvements (if we're in an improvement loop)\n  try {\n    flashcardData = $node[\"Parse Improvements\"].json;\n    dataSource = \"Parse Improvements\";\n    console.log(`üîÑ Using improved flashcards (iteration ${flashcardData.iteration || 'unknown'})`);\n  } catch (e) {\n    // If Parse Improvements doesn't exist or hasn't executed, use Parse Flashcards\n    flashcardData = $node[\"Parse Flashcards\"].json;\n    dataSource = \"Parse Flashcards\";\n    console.log(`üîÑ Using initial flashcards`);\n  }\n  \n  // Validate we have flashcard data\n  if (!flashcardData || !flashcardData.flashcards || !Array.isArray(flashcardData.flashcards)) {\n    throw new Error('No valid flashcard data found');\n  }\n  \n  console.log(`üìä Selected ${flashcardData.flashcards.length} flashcards from ${dataSource}`);\n  \n  // Return the data with metadata about which source was used\n  return {\n    success: true,\n    flashcards: flashcardData.flashcards,\n    count: flashcardData.flashcards.length,\n    sessionId: flashcardData.sessionId,\n    conceptsUsed: flashcardData.conceptsUsed,\n    conceptBreakdown: flashcardData.conceptBreakdown,\n    iteration: flashcardData.iteration,\n    maxIterations: flashcardData.maxIterations,\n    generationMethod: flashcardData.generationMethod,\n    improved: flashcardData.improved || false,\n    dataSource: dataSource,\n    \n    // Pass through any existing coverage analysis if available\n    coverageAnalysis: flashcardData.coverageAnalysis || null,\n    improvementReasons: flashcardData.improvementReasons || []\n  };\n  \n} catch (error) {\n  console.error('‚ùå Error selecting flashcard data:', error.message);\n  \n  // Fallback with minimal data\n  return {\n    success: false,\n    error: error.message,\n    flashcards: [\n      {\n        question: \"What are the main concepts from this session?\",\n        answer: \"This session covered important educational concepts that form the foundation for learning.\"\n      }\n    ],\n    count: 1,\n    sessionId: 'unknown',\n    conceptsUsed: 1,\n    conceptBreakdown: { high: 1, medium: 0, low: 0 },\n    iteration: 1,\n    maxIterations: 3,\n    generationMethod: 'fallback',\n    improved: false,\n    dataSource: 'fallback',\n    fallback: true\n  };\n}"
      },
      "id": "c04a2859-634c-4398-a8c4-490777d85200",
      "name": "Select Flashcards Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -820,
        0
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4.1-mini",
        "prompt": {
          "messages": [
            {
              "content": "=You are an expert educational content quality analyst. Perform a comprehensive concept coverage analysis for the generated flashcards.\n\nAnalyze the flashcards against the extracted concepts and provide detailed quality metrics:\n\n**EVALUATION CRITERIA:**\n1. **Concept Coverage Completeness** (0-10): How well do flashcards cover the extracted concepts?\n2. **Priority Concept Focus** (0-10): Are high-priority concepts adequately represented?\n3. **Coverage Depth Quality** (0-10): Do flashcards test understanding vs just memorization?\n4. **Coverage Distribution** (0-10): Is coverage balanced across concept categories?\n5. **Question Type Variety** (0-10): Are different cognitive levels tested (recall, application, analysis)?\n6. **Answer Comprehensiveness** (0-10): Do answers provide sufficient detail and context?\n7. **Concept Integration** (0-10): Do flashcards show relationships between concepts?\n8. **Educational Value** (0-10): Will these flashcards effectively help students learn?\n\n**ANALYSIS REQUIREMENTS:**\n- Identify specific concepts that are well-covered vs under-covered vs missing\n- Calculate coverage ratio for high/medium/low priority concepts\n- Assess cognitive complexity distribution\n- Identify coverage gaps and quality issues\n- Determine if improvement is needed and why\n\n\nYour response MUST be ONLY the raw JSON object, starting with `{` and ending with `}`. Do not include ```json, markdown formatting, or any other explanatory text.\n\nReturn ONLY this JSON format:\n{\n  \"overallScore\": 7.8,\n  \"coverageCompleteness\": 8,\n  \"priorityFocus\": 7,\n  \"depthQuality\": 8,\n  \"distribution\": 6,\n  \"questionVariety\": 7,\n  \"answerComprehensiveness\": 9,\n  \"conceptIntegration\": 7,\n  \"educationalValue\": 8,\n  \"needsImprovement\": true,\n  \"improvementReason\": \"Specific reason why improvement is needed\",\n  \"coverageAnalysis\": {\n    \"highPriorityCovered\": 4,\n    \"highPriorityTotal\": 6,\n    \"mediumPriorityCovered\": 3,\n    \"mediumPriorityTotal\": 4,\n    \"lowPriorityCovered\": 1,\n    \"lowPriorityTotal\": 2,\n    \"missingConcepts\": [\"Concept Name 1\", \"Concept Name 2\"],\n    \"wellCoveredConcepts\": [\"Concept Name 3\", \"Concept Name 4\"],\n    \"cognitiveDistribution\": {\n      \"recall\": 5,\n      \"understanding\": 3,\n      \"application\": 2,\n      \"analysis\": 0\n    }\n  },\n  \"recommendations\": [\n    \"Add flashcards for missing high-priority concepts\",\n    \"Increase cognitive complexity with application questions\",\n    \"Improve answer depth for concept X\"\n  ]\n}\n\n**IMPROVEMENT DECISION LOGIC:**\nRecommend improvement if:\n- Overall score < 7.5 OR\n- Priority focus < 7 OR\n- High-priority coverage < 80% OR\n- Missing critical concepts OR\n- Poor cognitive variety (>70% recall questions) OR\n- Answer quality issues\n\n**EXTRACTED CONCEPTS TO ANALYZE AGAINST:**\n{{ $node[\"Parse Concepts\"].json[\"conceptSummary\"] }}\n\n**CONCEPT STATISTICS:**\n- High Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"high\"] }}\n- Medium Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"medium\"] }}\n- Low Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"low\"] }}\n\n**FLASHCARDS TO ANALYZE:**\n{{ JSON.stringify($node[\"Select Flashcards Data\"].json[\"flashcards\"], null, 2) }}\n\nProvide comprehensive analysis with specific, actionable recommendations."
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "id": "9375c23e-c9dd-43fb-89b6-4f34b5c487df",
      "name": "Concept Coverage Analysis",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        -580,
        100
      ],
      "credentials": {
        "openAiApi": {
          "id": "KDqofqWJzHWJ0pPy",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse and analyze concept coverage assessment from AI\nlet response;\ntry {\n  const input = $input.first().json;\n  \n  // Handle the specific structure from your input (same as flashcard parser)\n  if (Array.isArray(input) && input.length > 0) {\n    // Handle array format: [{index: 0, message: {content: \"...\"}}]\n    response = input[0]?.message?.content;\n  } else if (input.choices && input.choices[0] && input.choices[0].message) {\n    // OpenAI format\n    response = input.choices[0].message.content;\n  } else if (input.choices && input.choices[0] && input.choices[0].text) {\n    // Alternative OpenAI format\n    response = input.choices[0].text;\n  } else if (input.text) {\n    response = input.text;\n  } else if (input.message) {\n    response = input.message;\n  } else {\n    response = JSON.stringify(input);\n  }\n} catch (e) {\n  response = 'Error accessing response';\n}\n\n// Get flashcard data from either initial parse or improvement iteration\nlet flashcardData;\ntry {\n  // Try to get from Parse Improvements first (if we're in an improvement loop)\n  flashcardData = $node[\"Parse Improvements\"].json;\n  console.log(`üîÑ Analyzing improved flashcards (iteration ${flashcardData.iteration || 'unknown'})`);\n} catch (e) {\n  // Fallback to Parse Flashcards (initial iteration)\n  flashcardData = $node[\"Parse Flashcards\"].json;\n  console.log(`üîÑ Analyzing initial flashcards`);\n}\n\nconst conceptData = $node[\"Parse Concepts\"].json;\n\ntry {\n  // Ensure response is always a string before processing\n  if (typeof response !== 'string') {\n    response = JSON.stringify(response);\n  }\n  \n  // Handle null or undefined responses\n  if (!response || response === 'null' || response === 'undefined') {\n    throw new Error('Empty or invalid response from AI');\n  }\n  \n  // Clean response and extract JSON with improved handling\n  let cleanResponse = response\n    .replace(/```json\\s*/g, '')  // Remove ```json with any whitespace\n    .replace(/```\\s*/g, '')      // Remove ``` with any whitespace\n    .replace(/^json\\s*/g, '')    // Remove 'json' at start with whitespace\n    .trim();\n  \n  // The content is a JSON string with literal \\n characters, so we need to parse it properly\n  // Don't remove \\n characters as they are part of the valid JSON structure\n  \n  console.log(`üîç Coverage analysis raw response length: ${response.length}`);\n  console.log(`üîç Coverage analysis cleaned response preview: ${cleanResponse.substring(0, 200)}...`);\n  \n  let coverageAnalysis;\ntry {\n  // First parse: Get the outer object\n  let outerObject = JSON.parse(cleanResponse);\n\n  // Get the inner JSON string from the 'content' field\n  let innerJsonString = outerObject.content;\n\n  // Second parse: Get the final object with the data you need\n  coverageAnalysis = JSON.parse(innerJsonString);\n  \n  console.log(`‚úÖ Successfully parsed nested JSON.`);\n  console.log(`üìä Parsed fields: ${Object.keys(coverageAnalysis).join(', ')}`);\n\n} catch (error) {\n  console.log(`‚ùå Failed to parse the nested JSON: ${error.message}`);\n  // You can add your original fallback/regex logic here if needed\n  throw new Error(`Critical JSON parsing failure: ${error.message}`);\n}\n\n// Validate analysis structure\nconst requiredFields = [\n  'overallScore', 'coverageCompleteness', 'priorityFocus', 'depthQuality',\n  'distribution', 'questionVariety', 'answerComprehensiveness', \n  'conceptIntegration', 'educationalValue', 'needsImprovement'\n];\n\nfor (const field of requiredFields) {\n  if (coverageAnalysis[field] === undefined) {\n    console.log(`‚ùå Missing required field: ${field}`);\n    console.log(`Available fields: ${Object.keys(coverageAnalysis).join(', ')}`);\n    throw new Error(`Missing required field: ${field}`);\n  }\n}\n  // Advanced improvement decision logic\n  const scores = {\n    overall: coverageAnalysis.overallScore || 0,\n    coverage: coverageAnalysis.coverageCompleteness || 0,\n    priority: coverageAnalysis.priorityFocus || 0,\n    depth: coverageAnalysis.depthQuality || 0,\n    distribution: coverageAnalysis.distribution || 0,\n    variety: coverageAnalysis.questionVariety || 0,\n    comprehensiveness: coverageAnalysis.answerComprehensiveness || 0,\n    integration: coverageAnalysis.conceptIntegration || 0,\n    educational: coverageAnalysis.educationalValue || 0\n  };\n  \n  // Calculate coverage ratios\n  const coverage = coverageAnalysis.coverageAnalysis || {};\n  const highPriorityCoverage = coverage.highPriorityTotal > 0 \n    ? (coverage.highPriorityCovered / coverage.highPriorityTotal) * 100 \n    : 100;\n  const mediumPriorityCoverage = coverage.mediumPriorityTotal > 0 \n    ? (coverage.mediumPriorityCovered / coverage.mediumPriorityTotal) * 100 \n    : 100;\n  const overallCoverage = (\n    (coverage.highPriorityCovered || 0) + \n    (coverage.mediumPriorityCovered || 0) + \n    (coverage.lowPriorityCovered || 0)\n  ) / (\n    (coverage.highPriorityTotal || 1) + \n    (coverage.mediumPriorityTotal || 0) + \n    (coverage.lowPriorityTotal || 0)\n  ) * 100;\n  \n  // Cognitive complexity analysis\n  const cognitive = coverage.cognitiveDistribution || {};\n  const totalCognitive = (cognitive.recall || 0) + (cognitive.understanding || 0) + \n                        (cognitive.application || 0) + (cognitive.analysis || 0);\n  const recallPercentage = totalCognitive > 0 ? (cognitive.recall || 0) / totalCognitive * 100 : 0;\n  const higherOrderPercentage = totalCognitive > 0 \n    ? ((cognitive.application || 0) + (cognitive.analysis || 0)) / totalCognitive * 100 \n    : 0;\n  \n  // Comprehensive improvement decision logic\n  const improvementNeeded = (\n    // AI recommendation\n    coverageAnalysis.needsImprovement ||\n    \n    // Score-based criteria\n    scores.overall < 7.5 ||\n    scores.priority < 7.0 ||\n    scores.coverage < 7.0 ||\n    scores.educational < 7.0 ||\n    \n    // Coverage-based criteria\n    highPriorityCoverage < 80 ||\n    overallCoverage < 70 ||\n    \n    // Quality-based criteria\n    recallPercentage > 70 ||  // Too many recall questions\n    higherOrderPercentage < 20 ||  // Not enough higher-order thinking\n    \n    // Content-based criteria\n    (coverage.missingConcepts && coverage.missingConcepts.length > 2) ||\n    flashcardData.flashcards.length < 6 ||\n    scores.comprehensiveness < 6.5\n  ) && flashcardData.iteration < flashcardData.maxIterations;\n  \n  // Create comprehensive improvement reasoning\n  let improvementReasons = [];\n  if (scores.overall < 7.5) improvementReasons.push(`Low overall score (${scores.overall}/10)`);\n  if (scores.priority < 7.0) improvementReasons.push(`Poor priority focus (${scores.priority}/10)`);\n  if (highPriorityCoverage < 80) improvementReasons.push(`High-priority coverage only ${highPriorityCoverage.toFixed(1)}%`);\n  if (recallPercentage > 70) improvementReasons.push(`Too many recall questions (${recallPercentage.toFixed(1)}%)`);\n  if (coverage.missingConcepts && coverage.missingConcepts.length > 0) {\n    improvementReasons.push(`Missing ${coverage.missingConcepts.length} concepts: ${coverage.missingConcepts.slice(0,3).join(', ')}`);\n  }\n  if (scores.comprehensiveness < 6.5) improvementReasons.push(`Answer quality needs improvement (${scores.comprehensiveness}/10)`);\n  \n  console.log(`üìä COMPREHENSIVE CONCEPT COVERAGE ANALYSIS:`);\n  console.log(`   üéØ Overall Score: ${scores.overall}/10`);\n  console.log(`   üìã Coverage Completeness: ${scores.coverage}/10`);\n  console.log(`   ‚≠ê Priority Focus: ${scores.priority}/10`);\n  console.log(`   üß† Cognitive Depth: ${scores.depth}/10`);\n  console.log(`   üìä High Priority Coverage: ${highPriorityCoverage.toFixed(1)}%`);\n  console.log(`   üîç Recall vs Higher-Order: ${recallPercentage.toFixed(1)}% vs ${higherOrderPercentage.toFixed(1)}%`);\n  console.log(`   ‚ùì Missing Concepts: ${coverage.missingConcepts?.length || 0}`);\n  console.log(`   üîÑ Needs Improvement: ${improvementNeeded}`);\n  if (improvementReasons.length > 0) {\n    console.log(`   üìù Reasons: ${improvementReasons.join('; ')}`);\n  }\n  \n  return {\n    success: true,\n    needsImprovement: improvementNeeded,\n    improvementReasons: improvementReasons,\n    \n    // Pass through original data\n    flashcards: flashcardData.flashcards,\n    count: flashcardData.flashcards.length,\n    sessionId: flashcardData.sessionId,\n    conceptsUsed: flashcardData.conceptsUsed,\n    conceptBreakdown: flashcardData.conceptBreakdown,\n    iteration: flashcardData.iteration,\n    maxIterations: flashcardData.maxIterations,\n    generationMethod: flashcardData.generationMethod,\n    \n    // Add comprehensive coverage analysis\n    coverageAnalysis: {\n      scores: scores,\n      coverageMetrics: {\n        highPriorityCoverage: highPriorityCoverage,\n        mediumPriorityCoverage: mediumPriorityCoverage,\n        overallCoverage: overallCoverage\n      },\n      cognitiveAnalysis: {\n        recallPercentage: recallPercentage,\n        higherOrderPercentage: higherOrderPercentage,\n        distribution: cognitive\n      },\n      missingConcepts: coverage.missingConcepts || [],\n      wellCoveredConcepts: coverage.wellCoveredConcepts || [],\n      recommendations: coverageAnalysis.recommendations || [],\n      aiAssessment: coverageAnalysis.improvementReason || 'No specific reason provided'\n    }\n  };\n  \n} catch (error) {\n  console.error('‚ùå Error parsing coverage analysis:', error.message);\n  console.error('Raw analysis response:', response);\n  \n  // Fallback to basic improvement logic\n  const basicNeedsImprovement = (\n    flashcardData.flashcards.length < 8 || \n    flashcardData.flashcards.length < conceptData.priorityBreakdown.high * 1.2\n  ) && flashcardData.iteration < flashcardData.maxIterations;\n  \n  return {\n    success: false,\n    error: error.message,\n    needsImprovement: basicNeedsImprovement,\n    improvementReasons: ['Coverage analysis failed - using basic logic'],\n    \n    // Pass through original data\n    flashcards: flashcardData.flashcards,\n    count: flashcardData.flashcards.length,\n    sessionId: flashcardData.sessionId,\n    conceptsUsed: flashcardData.conceptsUsed,\n    conceptBreakdown: flashcardData.conceptBreakdown,\n    iteration: flashcardData.iteration,\n    maxIterations: flashcardData.maxIterations,\n    generationMethod: flashcardData.generationMethod + '-fallback',\n    \n    coverageAnalysis: {\n      scores: { overall: 6, coverage: 6, priority: 6 },\n      fallback: true,\n      error: error.message\n    }\n  };\n}"
      },
      "id": "0cc7c2cd-d555-4e0f-95d4-ef89bd1f85cc",
      "name": "Parse Coverage Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -440,
        0
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.needsImprovement }}",
              "value2": true
            }
          ]
        }
      },
      "id": "709d7e59-8a77-442a-8a5d-545ff0d7957f",
      "name": "Need Improvement?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -260,
        0
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4.1-mini",
        "prompt": {
          "messages": [
            {
              "content": "=You are an expert educational content improver. Based on comprehensive concept coverage analysis, enhance the flashcards to address identified gaps and quality issues.\n\n**SPECIFIC IMPROVEMENT REQUIREMENTS:**\n\nüéØ **Coverage Analysis Results:**\n- Overall Score: {{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"scores\"][\"overall\"] }}/10\n- Priority Focus: {{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"scores\"][\"priority\"] }}/10\n- High Priority Coverage: {{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"coverageMetrics\"][\"highPriorityCoverage\"] }}%\n- Cognitive Complexity: {{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"cognitiveAnalysis\"][\"higherOrderPercentage\"] }}% higher-order thinking\n\nüîç **Missing Concepts to Address:**\n{{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"missingConcepts\"].join(\", \") }}\n\nüìä **AI Recommendations:**\n{{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"recommendations\"].join(\"\\n\") }}\n\nüí° **Improvement Reasons:**\n{{ $node[\"Parse Coverage Analysis\"].json[\"improvementReasons\"].join(\"; \") }}\n\n**ENHANCEMENT GUIDELINES:**\n1. **Address Missing Concepts**: Create flashcards for each missing high-priority concept\n2. **Increase Cognitive Complexity**: Add application, analysis, and synthesis questions\n3. **Improve Answer Depth**: Provide more comprehensive, contextual answers\n4. **Enhance Question Variety**: Use different question types (definition, comparison, application, problem-solving)\n5. **Strengthen Concept Integration**: Show relationships between concepts\n6. **Target Weak Areas**: Focus on concepts with poor coverage scores\n\n**COGNITIVE LEVEL TARGETS:**\n- Recall/Recognition: 30% (basic definitions, facts)\n- Understanding/Comprehension: 35% (explanations, examples)\n- Application: 25% (using concepts in scenarios)\n- Analysis/Evaluation: 10% (comparing, critiquing, problem-solving)\n\nModify old, and generate new and improved flashcards that specifically address the identified gaps. Return ONLY a JSON array:\n[{\"question\": \"Enhanced question addressing specific gap...\", \"answer\": \"Comprehensive answer with context and details...\"}, {\"question\": \"Application-level question...\", \"answer\": \"Detailed answer showing practical usage...\"}]\n\n**CURRENT FLASHCARDS TO IMPROVE:**\n{{ JSON.stringify($node[\"Parse Coverage Analysis\"].json[\"flashcards\"], null, 2) }}\n\n**COMPLETE CONCEPT REFERENCE:**\n{{ $node[\"Parse Concepts\"].json[\"conceptSummary\"] }}\n\nFocus on comprehensive coverage while maintaining educational quality and cognitive variety."
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "id": "3c1c4457-09e0-4d1e-ba3e-2e5003e93d3f",
      "name": "Improve Flashcards",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        -300,
        -220
      ],
      "credentials": {
        "openAiApi": {
          "id": "KDqofqWJzHWJ0pPy",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse improved flashcards - Rewritten for clarity and better error handling\n\nfunction extractResponseContent(input) {\n  console.log(`üîç Input type: ${typeof input}`);\n  console.log(`üîç Input structure: ${JSON.stringify(input, null, 2).substring(0, 300)}...`);\n  \n  // Handle different input structures\n  if (Array.isArray(input) && input[0]?.message?.content) {\n    console.log(`‚úÖ Found content in array structure`);\n    return input[0].message.content;\n  }\n  \n  if (input.choices?.[0]?.message?.content) {\n    console.log(`‚úÖ Found content in choices structure`);\n    return input.choices[0].message.content;\n  }\n  \n  if (input.choices?.[0]?.text) {\n    console.log(`‚úÖ Found text in choices structure`);\n    return input.choices[0].text;\n  }\n  \n  if (input.text) {\n    console.log(`‚úÖ Found text property`);\n    return input.text;\n  }\n  \n  if (input.message?.content) {\n    console.log(`‚úÖ Found content in message structure`);\n    return input.message.content;\n  }\n  \n  if (input.message) {\n    console.log(`‚úÖ Found message property`);\n    return input.message;\n  }\n  \n  if (input.content) {\n    console.log(`‚úÖ Found content property`);\n    return input.content;\n  }\n  \n  console.log(`‚ö†Ô∏è No matching structure found, returning stringified input`);\n  return JSON.stringify(input);\n}\n\nfunction cleanJsonString(str) {\n  if (typeof str !== 'string') {\n    str = JSON.stringify(str);\n  }\n  \n  return str\n    .replace(/```json\\s*/g, '')\n    .replace(/```\\s*/g, '')\n    .replace(/^json\\s*/g, '')\n    .trim();\n}\n\nfunction parseFlashcards(responseText) {\n  if (!responseText || responseText === 'null' || responseText === 'undefined') {\n    throw new Error('Empty or invalid response from AI');\n  }\n  \n  let cleanResponse = cleanJsonString(responseText);\n  console.log(`üîç Cleaned response preview: ${cleanResponse.substring(0, 200)}...`);\n  \n  let flashcards;\n  \n  // Try direct JSON parse first\n  try {\n    flashcards = JSON.parse(cleanResponse);\n    console.log(`‚úÖ Successfully parsed JSON directly`);\n  } catch (e) {\n    console.log(`‚ö†Ô∏è Direct parse failed: ${e.message}`);\n    console.log(`üîç Raw response type: ${typeof responseText}`);\n    console.log(`üîç Raw response length: ${responseText.length}`);\n    \n    // The content might be a JSON string with escaped characters\n    // Try to handle escaped JSON\n    try {\n      // First, try to parse as escaped JSON string\n      const unescapedJson = JSON.parse(responseText);\n      if (typeof unescapedJson === 'string') {\n        flashcards = JSON.parse(unescapedJson);\n        console.log(`‚úÖ Successfully parsed escaped JSON string`);\n      } else if (Array.isArray(unescapedJson)) {\n        flashcards = unescapedJson;\n        console.log(`‚úÖ Successfully parsed JSON object`);\n      } else {\n        throw new Error('Unexpected JSON structure');\n      }\n    } catch (escapeError) {\n      console.log(`‚ö†Ô∏è Escaped JSON parse failed: ${escapeError.message}`);\n      \n      // Fallback: extract JSON array using regex\n      const jsonMatch = cleanResponse.match(/\\[[\\s\\S]*\\]/);\n      if (!jsonMatch) {\n        throw new Error('Could not find valid JSON array in response');\n      }\n      \n      try {\n        flashcards = JSON.parse(jsonMatch[0]);\n        console.log(`‚úÖ Successfully parsed JSON from regex match`);\n      } catch (parseError) {\n        throw new Error(`Failed to parse extracted JSON: ${parseError.message}`);\n      }\n    }\n  }\n  \n  if (!Array.isArray(flashcards)) {\n    console.log(`‚ùå Parsed result type: ${typeof flashcards}`);\n    console.log(`‚ùå Parsed result: ${JSON.stringify(flashcards, null, 2).substring(0, 200)}...`);\n    throw new Error('Response is not an array');\n  }\n  \n  return flashcards;\n}\n\nfunction validateFlashcards(flashcards) {\n  return flashcards.filter(card => \n    card && \n    typeof card === 'object' &&\n    card.question && \n    card.answer &&\n    typeof card.question === 'string' && \n    typeof card.answer === 'string' &&\n    card.question.trim().length > 5 &&\n    card.answer.trim().length > 10\n  );\n}\n\nfunction createSuccessResponse(flashcards, previousData, conceptData) {\n  const currentIteration = (previousData.iteration || 1) + 1;\n  console.log(`üîÑ Iteration ${currentIteration}: Processed ${flashcards.length} flashcards (from ${conceptData.conceptCount} concepts)`);\n  \n  return {\n    success: true,\n    flashcards: flashcards,\n    count: flashcards.length,\n    sessionId: previousData.sessionId,\n    conceptsUsed: conceptData.conceptCount,\n    conceptBreakdown: conceptData.priorityBreakdown,\n    improved: true,\n    iteration: currentIteration,\n    maxIterations: previousData.maxIterations,\n    generationMethod: 'concept-based-improved'\n  };\n}\n\nfunction createErrorResponse(error, previousData, conceptData) {\n  console.error(`‚ùå Error parsing improved flashcards:`, error.message);\n  \n  return {\n    success: false,\n    error: error.message,\n    flashcards: previousData.flashcards,\n    count: previousData.flashcards.length,\n    sessionId: previousData.sessionId,\n    conceptsUsed: conceptData.conceptCount,\n    conceptBreakdown: conceptData.priorityBreakdown,\n    improved: false,\n    generationMethod: 'concept-based-fallback'\n  };\n}\n\n// Main execution\ntry {\n  const input = $input.first().json;\n  const previousData = $node[\"Parse Coverage Analysis\"].json; \n  const conceptData = $node[\"Parse Concepts\"].json;\n  \n  // Extract response content\n  const responseContent = extractResponseContent(input);\n  \n  // Parse and validate flashcards\n  const parsedFlashcards = parseFlashcards(responseContent);\n  const validFlashcards = validateFlashcards(parsedFlashcards);\n  \n  if (validFlashcards.length === 0) {\n    throw new Error('No valid flashcards found after validation');\n  }\n  \n  return createSuccessResponse(validFlashcards, previousData, conceptData);\n  \n} catch (error) {\n  const previousData = $node[\"Parse Coverage Analysis\"].json; \n  const conceptData = $node[\"Parse Concepts\"].json;\n  \n  return createErrorResponse(error, previousData, conceptData);\n}"
      },
      "id": "cf2f9e9c-7a93-4f31-a731-cc1bd418054e",
      "name": "Parse Improvements",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -100,
        -220
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare final response with concept analysis\nlet inputData;\n\n// Check which path we came from (improvement or direct)\nif ($input.first().json.improved !== undefined) {\n  // Came from improvement path\n  inputData = $input.first().json;\n} else {\n  // Came directly from parse flashcards\n  inputData = $input.first().json;\n}\n\nconst finalResponse = {\n  success: true,\n  flashcards: inputData.flashcards,\n  metadata: {\n    totalCards: inputData.flashcards.length,\n    sessionId: inputData.sessionId,\n    generatedAt: new Date().toISOString(),\n    generationMethod: inputData.generationMethod || 'concept-based',\n    improved: inputData.improved || false,\n    processingComplete: true,\n    \n    // Concept analysis metadata\n    conceptAnalysis: {\n      totalConcepts: inputData.conceptsUsed,\n      priorityBreakdown: inputData.conceptBreakdown,\n      coverageRatio: (inputData.flashcards.length / inputData.conceptsUsed).toFixed(2),\n      \n      // Comprehensive coverage analysis (if available)\n      qualityScores: inputData.coverageAnalysis?.scores || {},\n      coverageMetrics: inputData.coverageAnalysis?.coverageMetrics || {},\n      cognitiveAnalysis: inputData.coverageAnalysis?.cognitiveAnalysis || {},\n      missingConcepts: inputData.coverageAnalysis?.missingConcepts || [],\n      recommendations: inputData.coverageAnalysis?.recommendations || [],\n      improvementReasons: inputData.improvementReasons || []\n    }\n  }\n};\n\n// Add flags for different scenarios\nif (inputData.fallback) {\n  finalResponse.metadata.fallback = true;\n  finalResponse.metadata.note = \"Used fallback flashcards due to parsing issues\";\n}\n\nif (inputData.error) {\n  finalResponse.metadata.warnings = [inputData.error];\n}\n\nif (!inputData.success) {\n  finalResponse.metadata.processingIssues = true;\n}\n\n// Enhanced logging with concept information\nconsole.log(`üéâ CONCEPT-BASED FLASHCARD GENERATION COMPLETE!`);\nconsole.log(`   üìö Generated: ${inputData.flashcards.length} flashcards`);\nconsole.log(`   üß† From Concepts: ${inputData.conceptsUsed}`);\nconsole.log(`   üìä Priority Breakdown: High(${inputData.conceptBreakdown?.high || 0}), Medium(${inputData.conceptBreakdown?.medium || 0}), Low(${inputData.conceptBreakdown?.low || 0})`);\nconsole.log(`   üìã Session: ${inputData.sessionId}`);\nconsole.log(`   üîÑ Improved: ${inputData.improved || false}`);\nconsole.log(`   ‚ö° Method: ${inputData.generationMethod}`);\n\nreturn finalResponse;"
      },
      "id": "dbb22c9e-e193-4a47-876b-583f46e4cf19",
      "name": "Final Response Builder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -60,
        20
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json, null, 2) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Methods",
                "value": "POST, OPTIONS"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type, Authorization"
              }
            ]
          }
        }
      },
      "id": "01555c11-5ab5-4732-aae8-e0c29e523045",
      "name": "Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        160,
        20
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Initialize Variables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Variables": {
      "main": [
        [
          {
            "node": "Extract Concepts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Concepts": {
      "main": [
        [
          {
            "node": "Parse Concepts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Concepts": {
      "main": [
        [
          {
            "node": "Generate Flashcards",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Flashcards": {
      "main": [
        [
          {
            "node": "Parse Flashcards",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Flashcards": {
      "main": [
        [
          {
            "node": "Select Flashcards Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Select Flashcards Data": {
      "main": [
        [
          {
            "node": "Concept Coverage Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Concept Coverage Analysis": {
      "main": [
        [
          {
            "node": "Parse Coverage Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Coverage Analysis": {
      "main": [
        [
          {
            "node": "Need Improvement?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need Improvement?": {
      "main": [
        [
          {
            "node": "Improve Flashcards",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Final Response Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Improve Flashcards": {
      "main": [
        [
          {
            "node": "Parse Improvements",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Improvements": {
      "main": [
        [
          {
            "node": "Select Flashcards Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Final Response Builder": {
      "main": [
        [
          {
            "node": "Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1ee7524f-3542-4f45-a1f4-021b614b9fc8",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "304854bba464753094d47904a80cc1b97958d7982642a8841539c1e44d30ce2d"
  },
  "id": "285dLteF58gruqYD",
  "tags": [
    {
      "createdAt": "2025-07-02T22:09:42.701Z",
      "updatedAt": "2025-07-02T22:09:42.701Z",
      "id": "Ai3tR3tnqZS9aKqB",
      "name": "education"
    },
    {
      "createdAt": "2025-07-02T22:09:42.732Z",
      "updatedAt": "2025-07-02T22:09:42.732Z",
      "id": "cnJbCEFgHf6YuA2e",
      "name": "ai"
    },
    {
      "createdAt": "2025-07-02T22:09:42.677Z",
      "updatedAt": "2025-07-02T22:09:42.677Z",
      "id": "foaAUbmIIbF2izYw",
      "name": "cognify"
    },
    {
      "createdAt": "2025-07-03T01:17:31.760Z",
      "updatedAt": "2025-07-03T01:17:31.760Z",
      "id": "yaFQDsDuwGLPusD7",
      "name": "adaptive"
    }
  ]
}