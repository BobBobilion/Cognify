{
  "name": "My workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-flashcards",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "4603ff7e-7e69-4ab9-aca4-77ca8aab2a58",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -2160,
        160
      ],
      "webhookId": "cognify-flashcards"
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "transcript",
              "value": "={{ $json.body.transcript }}"
            },
            {
              "name": "sessionId",
              "value": "={{ $json.body.sessionId || 'default' }}"
            }
          ],
          "number": [
            {
              "name": "iteration",
              "value": 1
            },
            {
              "name": "maxIterations",
              "value": 3
            }
          ]
        },
        "options": {}
      },
      "id": "2c3f1df6-72e9-4e51-b6a4-e1b3d17a9090",
      "name": "Initialize Variables",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        -1960,
        160
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4.1-mini",
        "prompt": {
          "messages": [
            {
              "content": "=You are an expert educational content analyzer. Your task is to extract and organize the most important concepts from educational content.  Analyze the provided transcript and create a detailed, structured list of important concepts that would be valuable for students to learn and remember.  For each concept, provide: 1. **Concept Name**: Clear, concise title 2. **Category**: Type of concept (definition, process, principle, formula, example, etc.) 3. **Importance Level**: High, Medium, or Low 4. **Description**: 2-3 sentence explanation of why this concept matters 5. **Key Details**: Specific facts, steps, or components to remember  Return ONLY a JSON array in this exact format: [   {     \"name\": \"Machine Learning Definition\",     \"category\": \"definition\",     \"importance\": \"High\",     \"description\": \"Fundamental concept that defines the entire field. Students must understand this core definition to grasp all subsequent topics.\",     \"keyDetails\": [\"Subset of AI\", \"Learns from data without explicit programming\", \"Improves performance through experience\"]   },   {     \"name\": \"Supervised Learning Process\",     \"category\": \"process\",     \"importance\": \"High\",      \"description\": \"Core methodology that forms the foundation of most practical ML applications. Understanding this process is essential for implementation.\",     \"keyDetails\": [\"Uses labeled training data\", \"Learns input-output relationships\", \"Makes predictions on new data\"]   } ]  Extract 8-15 concepts from this transcript, but generate more if needed. Focus on concepts that would make excellent flashcard material.  Transcript to analyze: {{ $node[\"Initialize Variables\"].json[\"transcript\"] }}"
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "id": "4f01ef09-c005-4e77-966a-295fe01d3525",
      "name": "Extract Concepts",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        -1760,
        160
      ],
      "credentials": {
        "openAiApi": {
          "id": "KDqofqWJzHWJ0pPy",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse and validate extracted concepts from AI response\nlet response;\ntry {\n  const input = $input.first().json;\n  \n  // Try different response formats\n  if (input.choices && input.choices[0] && input.choices[0].message) {\n    response = input.choices[0].message.content;\n  } else if (input.choices && input.choices[0] && input.choices[0].text) {\n    response = input.choices[0].text;\n  } else if (input.text) {\n    response = input.text;\n  } else if (input.message) {\n    response = input.message;\n  } else {\n    response = JSON.stringify(input);\n  }\n} catch (e) {\n  response = 'Error accessing response';\n}\n\nconst sessionData = $node[\"Initialize Variables\"].json;\n\ntry {\n  // Ensure response is always a string before processing\n  if (typeof response !== 'string') {\n    response = JSON.stringify(response);\n  }\n  \n  // Handle null or undefined responses\n  if (!response || response === 'null' || response === 'undefined') {\n    throw new Error('Empty or invalid response from AI');\n  }\n  \n  // Clean response and extract JSON with improved handling\n  let cleanResponse = response\n    .replace(/```json\\s*/g, '')  // Remove ```json with any whitespace\n    .replace(/```\\s*/g, '')      // Remove ``` with any whitespace\n    .replace(/^json\\s*/g, '')    // Remove 'json' at start with whitespace\n    .trim();\n  \n  console.log(`🔍 Cleaned response preview: ${cleanResponse.substring(0, 100)}...`);\n  \n  // Try direct JSON parse first\n  let concepts;\n  try {\n    concepts = JSON.parse(cleanResponse);\n    console.log(`✅ Successfully parsed JSON directly`);\n  } catch (e) {\n    console.log(`⚠️ Direct parse failed: ${e.message}`);\n    \n    // Fallback: extract JSON array from text more robustly\n    const jsonMatch = cleanResponse.match(/\\[[\\s\\S]*\\]/);\n    if (jsonMatch) {\n      try {\n        concepts = JSON.parse(jsonMatch[0]);\n        console.log(`✅ Successfully parsed JSON from regex match`);\n      } catch (parseError) {\n        throw new Error(`Failed to parse extracted JSON: ${parseError.message}`);\n      }\n    } else {\n      throw new Error('No valid JSON array found in concepts response');\n    }\n  }\n  \n  // Validate array structure\n  if (!Array.isArray(concepts)) {\n    throw new Error('Concepts response is not an array');\n  }\n  \n  // Filter and validate concepts\n  const validConcepts = concepts.filter(concept => \n    concept && \n    typeof concept === 'object' &&\n    concept.name && \n    concept.category &&\n    concept.importance &&\n    concept.description &&\n    concept.keyDetails &&\n    typeof concept.name === 'string' && \n    typeof concept.category === 'string' &&\n    typeof concept.importance === 'string' &&\n    typeof concept.description === 'string' &&\n    Array.isArray(concept.keyDetails) &&\n    concept.name.trim().length > 3 &&\n    concept.description.trim().length > 10\n  );\n  \n  if (validConcepts.length === 0) {\n    throw new Error('No valid concepts found');\n  }\n  \n  // Organize concepts by importance\n  const highPriority = validConcepts.filter(c => c.importance.toLowerCase() === 'high');\n  const mediumPriority = validConcepts.filter(c => c.importance.toLowerCase() === 'medium');\n  const lowPriority = validConcepts.filter(c => c.importance.toLowerCase() === 'low');\n  \n  console.log(`✅ Extracted ${validConcepts.length} concepts:`);\n  console.log(`   📍 High Priority: ${highPriority.length}`);\n  console.log(`   📍 Medium Priority: ${mediumPriority.length}`);\n  console.log(`   📍 Low Priority: ${lowPriority.length}`);\n  \n  // Create structured concept summary for flashcard generation\n  const conceptSummary = validConcepts.map(concept => \n    `**${concept.name}** (${concept.category}, ${concept.importance} priority)\\n` +\n    `Description: ${concept.description}\\n` +\n    `Key Details: ${concept.keyDetails.join(', ')}\\n`\n  ).join('\\n');\n  \n  return {\n    success: true,\n    concepts: validConcepts,\n    conceptCount: validConcepts.length,\n    conceptSummary: conceptSummary,\n    priorityBreakdown: {\n      high: highPriority.length,\n      medium: mediumPriority.length,\n      low: lowPriority.length\n    },\n    sessionId: sessionData.sessionId,\n    transcript: sessionData.transcript,\n    iteration: sessionData.iteration,\n    maxIterations: sessionData.maxIterations\n  };\n  \n} catch (error) {\n  console.error(`❌ CRITICAL: PARSE CONCEPTS FAILED - USING FALLBACK!`);\n  console.error(`❌ Error:`, error.message);\n  console.error(`❌ Raw AI Response:`, response);\n  console.error(`❌ Response Length:`, response?.length || 'undefined');\n  console.error(`❌ This means Extract Concepts AI call failed or returned invalid JSON!`);\n  \n  // Create fallback concepts\n  const fallbackConcepts = [\n    {\n      name: \"Main Topic Overview\",\n      category: \"definition\",\n      importance: \"High\",\n      description: \"Core subject matter discussed in this educational session.\",\n      keyDetails: [\"Primary focus of the content\", \"Foundation for understanding\", \"Essential background knowledge\"]\n    },\n    {\n      name: \"Key Learning Objectives\",\n      category: \"principle\",\n      importance: \"High\", \n      description: \"Important goals and outcomes students should achieve from this material.\",\n      keyDetails: [\"Learning targets\", \"Skill development\", \"Knowledge acquisition\"]\n    },\n    {\n      name: \"Practical Applications\",\n      category: \"example\",\n      importance: \"Medium\",\n      description: \"Real-world uses and implementations of the discussed concepts.\",\n      keyDetails: [\"Industry applications\", \"Problem-solving examples\", \"Use cases\"]\n    }\n  ];\n  \n  const fallbackSummary = fallbackConcepts.map(concept => \n    `**${concept.name}** (${concept.category}, ${concept.importance} priority)\\n` +\n    `Description: ${concept.description}\\n` +\n    `Key Details: ${concept.keyDetails.join(', ')}\\n`\n  ).join('\\n');\n  \n  return {\n    success: false,\n    error: error.message,\n    concepts: fallbackConcepts,\n    conceptCount: fallbackConcepts.length,\n    conceptSummary: fallbackSummary,\n    priorityBreakdown: { high: 2, medium: 1, low: 0 },\n    sessionId: sessionData.sessionId,\n    transcript: sessionData.transcript,\n    iteration: sessionData.iteration,\n    maxIterations: sessionData.maxIterations,\n    fallback: true\n  };\n}"
      },
      "id": "fc3f2a66-304d-4c30-809b-e2ad17e6bab9",
      "name": "Parse Concepts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -1560,
        160
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4.1-mini",
        "prompt": {
          "messages": [
            {
              "content": "=You are an expert educational flashcard creator. Generate high-quality flashcards based on the provided concept analysis.  Flashcard Generation Guidelines: - Create 8-12 flashcards covering the most important concepts - Prioritize HIGH importance concepts, include some MEDIUM importance - Use varied question types: definitions, explanations, applications, comparisons - Make questions specific and clear - Provide comprehensive but concise answers - Ensure appropriate difficulty level for the content  For each concept, consider creating flashcards that test: 1. **Definition/Understanding**: \"What is...?\" \"Define...\" \"Explain...\" 2. **Application**: \"How would you use...?\" \"When should you apply...?\" 3. **Analysis**: \"What are the key differences between...?\" \"Why is this important?\" 4. **Synthesis**: \"How do these concepts relate?\" \"What would happen if...?\"  Return ONLY a valid JSON array of flashcards: [{\"question\": \"What is machine learning?\", \"answer\": \"Machine learning is a subset of artificial intelligence that enables computers to learn and improve from experience without being explicitly programmed. It uses data to identify patterns and make predictions or decisions.\"}, {\"question\": \"What are the three main types of machine learning?\", \"answer\": \"The three main types are: 1) Supervised learning (uses labeled data), 2) Unsupervised learning (finds patterns in unlabeled data), and 3) Reinforcement learning (learns through trial and error with rewards and penalties).\"}]  **EXTRACTED CONCEPTS TO USE:** {{ $node[\"Parse Concepts\"].json[\"conceptSummary\"] }}  **CONCEPT STATISTICS:** - Total Concepts: {{ $node[\"Parse Concepts\"].json[\"conceptCount\"] }} - High Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"high\"] }} - Medium Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"medium\"] }} - Low Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"low\"] }}  Generate flashcards that comprehensively cover these concepts, focusing on the high-priority items first."
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "id": "5ac660b7-d538-4973-9df2-6e066d34a398",
      "name": "Generate Flashcards",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        -1360,
        160
      ],
      "credentials": {
        "openAiApi": {
          "id": "KDqofqWJzHWJ0pPy",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse and validate flashcards from OpenAI response\nlet response;\ntry {\n  const input = $input.first().json;\n  \n  // Try different response formats\n  if (input.choices && input.choices[0] && input.choices[0].message) {\n    response = input.choices[0].message.content;\n  } else if (input.choices && input.choices[0] && input.choices[0].text) {\n    response = input.choices[0].text;\n  } else if (input.text) {\n    response = input.text;\n  } else if (input.message) {\n    response = input.message;\n  } else {\n    response = JSON.stringify(input);\n  }\n} catch (e) {\n  response = 'Error accessing response';\n}\n\nconst conceptData = $node[\"Parse Concepts\"].json;\n\ntry {\n  // Ensure response is always a string before processing\n  if (typeof response !== 'string') {\n    response = JSON.stringify(response);\n  }\n  \n  // Handle null or undefined responses\n  if (!response || response === 'null' || response === 'undefined') {\n    throw new Error('Empty or invalid response from AI');\n  }\n  \n  // Clean response and extract JSON with improved handling\n  let cleanResponse = response\n    .replace(/```json\\s*/g, '')  // Remove ```json with any whitespace\n    .replace(/```\\s*/g, '')      // Remove ``` with any whitespace\n    .replace(/^json\\s*/g, '')    // Remove 'json' at start with whitespace\n    .trim();\n  \n  console.log(`🔍 Flashcards cleaned response preview: ${cleanResponse.substring(0, 100)}...`);\n  \n  // Try direct JSON parse first\n  let flashcards;\n  try {\n    flashcards = JSON.parse(cleanResponse);\n    console.log(`✅ Successfully parsed flashcards JSON directly`);\n  } catch (e) {\n    console.log(`⚠️ Direct flashcards parse failed: ${e.message}`);\n    \n    // Fallback: extract JSON array from text more robustly\n    const jsonMatch = cleanResponse.match(/\\[[\\s\\S]*\\]/);\n    if (jsonMatch) {\n      try {\n        flashcards = JSON.parse(jsonMatch[0]);\n        console.log(`✅ Successfully parsed flashcards JSON from regex match`);\n      } catch (parseError) {\n        throw new Error(`Failed to parse extracted flashcards JSON: ${parseError.message}`);\n      }\n    } else {\n      throw new Error('No valid JSON array found in flashcards response');\n    }\n  }\n  \n  // Validate array structure\n  if (!Array.isArray(flashcards)) {\n        console.log(`❌ PARSE ERROR: Expected array but got ${typeof flashcards}`);\n    console.log(`🔍 Value:`, flashcards);\n    console.log(`📝 AI Response:`, response.substring(0, 300));\n        // Handle object responses that wrap the array\\n    if (typeof flashcards === 'object' && flashcards !== null) {\\n      console.log(`⚠️ Trying to extract array from object...`);\\n      if (flashcards.flashcards && Array.isArray(flashcards.flashcards)) {\\n        flashcards = flashcards.flashcards;\\n        console.log(`✅ Extracted array from object.flashcards`);\\n      } else if (flashcards.cards && Array.isArray(flashcards.cards)) {\\n        flashcards = flashcards.cards;\\n        console.log(`✅ Extracted array from object.cards`);\\n      } else {\\n        // Find any array property\\n        const arrayKeys = Object.keys(flashcards).filter(key => Array.isArray(flashcards[key]));\\n        if (arrayKeys.length > 0) {\\n          flashcards = flashcards[arrayKeys[0]];\\n          console.log(`✅ Extracted array from object.${arrayKeys[0]}`);\\n        } else {\\n          console.log(`❌ Object has no arrays:`, Object.keys(flashcards));\\n          throw new Error(`Object contains no flashcards array`);\\n        }\\n      }\\n    } else {\\n      throw new Error(`Response is not an array - got ${typeof flashcards}`);\\n    }\n  }\n  \n  // Filter valid flashcards\n  // Final validation: ensure we have an array before calling filter\\n  if (!Array.isArray(flashcards)) {\\n    console.log(`❌ CRITICAL: Still not an array after all extraction attempts`);\\n    console.log(`❌ Type: ${typeof flashcards}`);\\n    console.log(`❌ Value:`, flashcards);\\n    throw new Error(`Cannot call filter on non-array: ${typeof flashcards}`);\\n  }\\n  \\n  console.log(`✅ Confirmed array with ${flashcards.length} items, proceeding to filter`);\\n  \\n  const validCards = flashcards.filter(card => \n    card && \n    typeof card === 'object' &&\n    card.question && \n    card.answer &&\n    typeof card.question === 'string' && \n    typeof card.answer === 'string' &&\n    card.question.trim().length > 5 &&\n    card.answer.trim().length > 10\n  );\n  \n  if (validCards.length === 0) {\n    throw new Error('No valid flashcards found');\n  }\n  \n  console.log(`✅ Generated ${validCards.length} flashcards from ${conceptData.conceptCount} concepts`);\n  \n  return {\n    success: true,\n    flashcards: validCards,\n    count: validCards.length,\n    sessionId: conceptData.sessionId,\n    conceptsUsed: conceptData.conceptCount,\n    conceptBreakdown: conceptData.priorityBreakdown,\n    needsImprovement: validCards.length < 8 && conceptData.iteration < conceptData.maxIterations,\n    iteration: conceptData.iteration,\n    maxIterations: conceptData.maxIterations,\n    generationMethod: 'concept-based'\n  };\n  \n} catch (error) {\n  console.error(`❌ CRITICAL: PARSE FLASHCARDS FAILED - USING FALLBACK!`);\n  console.error(`❌ Error:`, error.message);\n  console.error(`❌ Raw AI Response:`, response);\n  console.error(`❌ Response Length:`, response?.length || 'undefined');\n  console.error(`❌ This means either Extract Concepts, Generate Flashcards, or parsing failed!`);\n  \n  // Create fallback flashcards based on concepts\n  const fallbackCards = [\n    {\n      question: \"What are the main concepts covered in this educational content?\",\n      answer: \"The content covers several important concepts including key definitions, processes, and practical applications relevant to the subject matter.\"\n    },\n    {\n      question: \"Why are these concepts important for students to understand?\",\n      answer: \"These concepts form the foundation of knowledge in this subject area and are essential for further learning and practical application.\"\n    },\n    {\n      question: \"How can students apply the knowledge from this session?\",\n      answer: \"Students can apply this knowledge through practice exercises, real-world problem solving, and by connecting these concepts to related topics.\"\n    }\n  ];\n  \n  return {\n    success: false,\n    error: error.message,\n    flashcards: fallbackCards,\n    count: fallbackCards.length,\n    sessionId: conceptData.sessionId,\n    conceptsUsed: conceptData.conceptCount,\n    conceptBreakdown: conceptData.priorityBreakdown,\n    needsImprovement: false,\n    iteration: conceptData.iteration,\n    maxIterations: conceptData.maxIterations,\n    fallback: true,\n    generationMethod: 'concept-based-fallback'\n  };\n}"
      },
      "id": "1f7884d5-9022-4cc3-a89c-7ce5d5671d57",
      "name": "Parse Flashcards",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -1160,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "// Smart function to select appropriate flashcard data for analysis\n// This handles the branch logic to avoid n8n's \"Referenced node is unexecuted\" error\n\nlet flashcardData;\nlet dataSource;\n\ntry {\n  // First, try to get data from Parse Improvements (if we're in an improvement loop)\n  try {\n    flashcardData = $node[\"Parse Improvements\"].json;\n    dataSource = \"Parse Improvements\";\n    console.log(`🔄 Using improved flashcards (iteration ${flashcardData.iteration || 'unknown'})`);\n  } catch (e) {\n    // If Parse Improvements doesn't exist or hasn't executed, use Parse Flashcards\n    flashcardData = $node[\"Parse Flashcards\"].json;\n    dataSource = \"Parse Flashcards\";\n    console.log(`🔄 Using initial flashcards`);\n  }\n  \n  // Validate we have flashcard data\n  if (!flashcardData || !flashcardData.flashcards || !Array.isArray(flashcardData.flashcards)) {\n    throw new Error('No valid flashcard data found');\n  }\n  \n  console.log(`📊 Selected ${flashcardData.flashcards.length} flashcards from ${dataSource}`);\n  \n  // Return the data with metadata about which source was used\n  return {\n    success: true,\n    flashcards: flashcardData.flashcards,\n    count: flashcardData.flashcards.length,\n    sessionId: flashcardData.sessionId,\n    conceptsUsed: flashcardData.conceptsUsed,\n    conceptBreakdown: flashcardData.conceptBreakdown,\n    iteration: flashcardData.iteration,\n    maxIterations: flashcardData.maxIterations,\n    generationMethod: flashcardData.generationMethod,\n    improved: flashcardData.improved || false,\n    dataSource: dataSource,\n    \n    // Pass through any existing coverage analysis if available\n    coverageAnalysis: flashcardData.coverageAnalysis || null,\n    improvementReasons: flashcardData.improvementReasons || []\n  };\n  \n} catch (error) {\n  console.error('❌ Error selecting flashcard data:', error.message);\n  \n  // Fallback with minimal data\n  return {\n    success: false,\n    error: error.message,\n    flashcards: [\n      {\n        question: \"What are the main concepts from this session?\",\n        answer: \"This session covered important educational concepts that form the foundation for learning.\"\n      }\n    ],\n    count: 1,\n    sessionId: 'unknown',\n    conceptsUsed: 1,\n    conceptBreakdown: { high: 1, medium: 0, low: 0 },\n    iteration: 1,\n    maxIterations: 3,\n    generationMethod: 'fallback',\n    improved: false,\n    dataSource: 'fallback',\n    fallback: true\n  };\n}"
      },
      "id": "7b8c9d1e-2f3a-4b5c-8e7f-9a0b1c2d3e4f",
      "name": "Select Flashcards Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -1040,
        160
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4.1-mini",
        "prompt": {
          "messages": [
            {
              "content": "=You are an expert educational content quality analyst. Perform a comprehensive concept coverage analysis for the generated flashcards.\n\nAnalyze the flashcards against the extracted concepts and provide detailed quality metrics:\n\n**EVALUATION CRITERIA:**\n1. **Concept Coverage Completeness** (0-10): How well do flashcards cover the extracted concepts?\n2. **Priority Concept Focus** (0-10): Are high-priority concepts adequately represented?\n3. **Coverage Depth Quality** (0-10): Do flashcards test understanding vs just memorization?\n4. **Coverage Distribution** (0-10): Is coverage balanced across concept categories?\n5. **Question Type Variety** (0-10): Are different cognitive levels tested (recall, application, analysis)?\n6. **Answer Comprehensiveness** (0-10): Do answers provide sufficient detail and context?\n7. **Concept Integration** (0-10): Do flashcards show relationships between concepts?\n8. **Educational Value** (0-10): Will these flashcards effectively help students learn?\n\n**ANALYSIS REQUIREMENTS:**\n- Identify specific concepts that are well-covered vs under-covered vs missing\n- Calculate coverage ratio for high/medium/low priority concepts\n- Assess cognitive complexity distribution\n- Identify coverage gaps and quality issues\n- Determine if improvement is needed and why\n\nReturn ONLY this JSON format:\n{\n  \"overallScore\": 7.8,\n  \"coverageCompleteness\": 8,\n  \"priorityFocus\": 7,\n  \"depthQuality\": 8,\n  \"distribution\": 6,\n  \"questionVariety\": 7,\n  \"answerComprehensiveness\": 9,\n  \"conceptIntegration\": 7,\n  \"educationalValue\": 8,\n  \"needsImprovement\": true,\n  \"improvementReason\": \"Specific reason why improvement is needed\",\n  \"coverageAnalysis\": {\n    \"highPriorityCovered\": 4,\n    \"highPriorityTotal\": 6,\n    \"mediumPriorityCovered\": 3,\n    \"mediumPriorityTotal\": 4,\n    \"lowPriorityCovered\": 1,\n    \"lowPriorityTotal\": 2,\n    \"missingConcepts\": [\"Concept Name 1\", \"Concept Name 2\"],\n    \"wellCoveredConcepts\": [\"Concept Name 3\", \"Concept Name 4\"],\n    \"cognitiveDistribution\": {\n      \"recall\": 5,\n      \"understanding\": 3,\n      \"application\": 2,\n      \"analysis\": 0\n    }\n  },\n  \"recommendations\": [\n    \"Add flashcards for missing high-priority concepts\",\n    \"Increase cognitive complexity with application questions\",\n    \"Improve answer depth for concept X\"\n  ]\n}\n\n**IMPROVEMENT DECISION LOGIC:**\nRecommend improvement if:\n- Overall score < 7.5 OR\n- Priority focus < 7 OR\n- High-priority coverage < 80% OR\n- Missing critical concepts OR\n- Poor cognitive variety (>70% recall questions) OR\n- Answer quality issues\n\n**EXTRACTED CONCEPTS TO ANALYZE AGAINST:**\n{{ $node[\"Parse Concepts\"].json[\"conceptSummary\"] }}\n\n**CONCEPT STATISTICS:**\n- High Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"high\"] }}\n- Medium Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"medium\"] }}\n- Low Priority: {{ $node[\"Parse Concepts\"].json[\"priorityBreakdown\"][\"low\"] }}\n\n**FLASHCARDS TO ANALYZE:**\n{{ JSON.stringify($node[\"Select Flashcards Data\"].json[\"flashcards\"], null, 2) }}\n\nProvide comprehensive analysis with specific, actionable recommendations."
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "id": "06831e7e-f97d-44f8-9ef0-e0973104b17e",
      "name": "Concept Coverage Analysis",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        -960,
        160
      ],
      "credentials": {
        "openAiApi": {
          "id": "KDqofqWJzHWJ0pPy",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse and analyze concept coverage assessment from AI\nlet response;\ntry {\n  const input = $input.first().json;\n  \n  // Try different response formats\n  if (input.choices && input.choices[0] && input.choices[0].message) {\n    response = input.choices[0].message.content;\n  } else if (input.choices && input.choices[0] && input.choices[0].text) {\n    response = input.choices[0].text;\n  } else if (input.text) {\n    response = input.text;\n  } else if (input.message) {\n    response = input.message;\n  } else {\n    response = JSON.stringify(input);\n  }\n} catch (e) {\n  response = 'Error accessing response';\n}\n\n// Get flashcard data from either initial parse or improvement iteration\nlet flashcardData;\ntry {\n  // Try to get from Parse Improvements first (if we're in an improvement loop)\n  flashcardData = $node[\"Parse Improvements\"].json;\n  console.log(`🔄 Analyzing improved flashcards (iteration ${flashcardData.iteration || 'unknown'})`);\n} catch (e) {\n  // Fallback to Parse Flashcards (initial iteration)\n  flashcardData = $node[\"Parse Flashcards\"].json;\n  console.log(`🔄 Analyzing initial flashcards`);\n}\n\nconst conceptData = $node[\"Parse Concepts\"].json;\n\ntry {\n  // Ensure response is always a string before processing\n  if (typeof response !== 'string') {\n    response = JSON.stringify(response);\n  }\n  \n  // Handle null or undefined responses\n  if (!response || response === 'null' || response === 'undefined') {\n    throw new Error('Empty or invalid response from AI');\n  }\n  \n  // Clean response and extract JSON with improved handling\n  let cleanResponse = response\n    .replace(/```json\\s*/g, '')  // Remove ```json with any whitespace\n    .replace(/```\\s*/g, '')      // Remove ``` with any whitespace\n    .replace(/^json\\s*/g, '')    // Remove 'json' at start with whitespace\n    .trim();\n  \n  console.log(`🔍 Coverage analysis cleaned response preview: ${cleanResponse.substring(0, 100)}...`);\n  \n  let coverageAnalysis;\n  try {\n    coverageAnalysis = JSON.parse(cleanResponse);\n    console.log(`✅ Successfully parsed coverage analysis JSON directly`);\n  } catch (e) {\n    console.log(`⚠️ Direct coverage analysis parse failed: ${e.message}`);\n    \n    // Fallback: try to extract JSON object more robustly\n    const jsonMatch = cleanResponse.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      try {\n        coverageAnalysis = JSON.parse(jsonMatch[0]);\n        console.log(`✅ Successfully parsed coverage analysis JSON from regex match`);\n      } catch (parseError) {\n        throw new Error(`Failed to parse extracted coverage analysis JSON: ${parseError.message}`);\n      }\n    } else {\n      throw new Error('No valid JSON object found in coverage analysis response');\n    }\n  }\n  \n  // Validate analysis structure\n  const requiredFields = [\n    'overallScore', 'coverageCompleteness', 'priorityFocus', 'depthQuality',\n    'distribution', 'questionVariety', 'answerComprehensiveness', \n    'conceptIntegration', 'educationalValue', 'needsImprovement'\n  ];\n  \n  for (const field of requiredFields) {\n    if (coverageAnalysis[field] === undefined) {\n      throw new Error(`Missing required field: ${field}`);\n    }\n  }\n  \n  // Advanced improvement decision logic\n  const scores = {\n    overall: coverageAnalysis.overallScore || 0,\n    coverage: coverageAnalysis.coverageCompleteness || 0,\n    priority: coverageAnalysis.priorityFocus || 0,\n    depth: coverageAnalysis.depthQuality || 0,\n    distribution: coverageAnalysis.distribution || 0,\n    variety: coverageAnalysis.questionVariety || 0,\n    comprehensiveness: coverageAnalysis.answerComprehensiveness || 0,\n    integration: coverageAnalysis.conceptIntegration || 0,\n    educational: coverageAnalysis.educationalValue || 0\n  };\n  \n  // Calculate coverage ratios\n  const coverage = coverageAnalysis.coverageAnalysis || {};\n  const highPriorityCoverage = coverage.highPriorityTotal > 0 \n    ? (coverage.highPriorityCovered / coverage.highPriorityTotal) * 100 \n    : 100;\n  const mediumPriorityCoverage = coverage.mediumPriorityTotal > 0 \n    ? (coverage.mediumPriorityCovered / coverage.mediumPriorityTotal) * 100 \n    : 100;\n  const overallCoverage = (\n    (coverage.highPriorityCovered || 0) + \n    (coverage.mediumPriorityCovered || 0) + \n    (coverage.lowPriorityCovered || 0)\n  ) / (\n    (coverage.highPriorityTotal || 1) + \n    (coverage.mediumPriorityTotal || 0) + \n    (coverage.lowPriorityTotal || 0)\n  ) * 100;\n  \n  // Cognitive complexity analysis\n  const cognitive = coverage.cognitiveDistribution || {};\n  const totalCognitive = (cognitive.recall || 0) + (cognitive.understanding || 0) + \n                        (cognitive.application || 0) + (cognitive.analysis || 0);\n  const recallPercentage = totalCognitive > 0 ? (cognitive.recall || 0) / totalCognitive * 100 : 0;\n  const higherOrderPercentage = totalCognitive > 0 \n    ? ((cognitive.application || 0) + (cognitive.analysis || 0)) / totalCognitive * 100 \n    : 0;\n  \n  // Comprehensive improvement decision logic\n  const improvementNeeded = (\n    // AI recommendation\n    coverageAnalysis.needsImprovement ||\n    \n    // Score-based criteria\n    scores.overall < 7.5 ||\n    scores.priority < 7.0 ||\n    scores.coverage < 7.0 ||\n    scores.educational < 7.0 ||\n    \n    // Coverage-based criteria\n    highPriorityCoverage < 80 ||\n    overallCoverage < 70 ||\n    \n    // Quality-based criteria\n    recallPercentage > 70 ||  // Too many recall questions\n    higherOrderPercentage < 20 ||  // Not enough higher-order thinking\n    \n    // Content-based criteria\n    (coverage.missingConcepts && coverage.missingConcepts.length > 2) ||\n    flashcardData.flashcards.length < 6 ||\n    scores.comprehensiveness < 6.5\n  ) && flashcardData.iteration < flashcardData.maxIterations;\n  \n  // Create comprehensive improvement reasoning\n  let improvementReasons = [];\n  if (scores.overall < 7.5) improvementReasons.push(`Low overall score (${scores.overall}/10)`);\n  if (scores.priority < 7.0) improvementReasons.push(`Poor priority focus (${scores.priority}/10)`);\n  if (highPriorityCoverage < 80) improvementReasons.push(`High-priority coverage only ${highPriorityCoverage.toFixed(1)}%`);\n  if (recallPercentage > 70) improvementReasons.push(`Too many recall questions (${recallPercentage.toFixed(1)}%)`);\n  if (coverage.missingConcepts && coverage.missingConcepts.length > 0) {\n    improvementReasons.push(`Missing ${coverage.missingConcepts.length} concepts: ${coverage.missingConcepts.slice(0,3).join(', ')}`);\n  }\n  if (scores.comprehensiveness < 6.5) improvementReasons.push(`Answer quality needs improvement (${scores.comprehensiveness}/10)`);\n  \n  console.log(`📊 COMPREHENSIVE CONCEPT COVERAGE ANALYSIS:`);\n  console.log(`   🎯 Overall Score: ${scores.overall}/10`);\n  console.log(`   📋 Coverage Completeness: ${scores.coverage}/10`);\n  console.log(`   ⭐ Priority Focus: ${scores.priority}/10`);\n  console.log(`   🧠 Cognitive Depth: ${scores.depth}/10`);\n  console.log(`   📊 High Priority Coverage: ${highPriorityCoverage.toFixed(1)}%`);\n  console.log(`   🔍 Recall vs Higher-Order: ${recallPercentage.toFixed(1)}% vs ${higherOrderPercentage.toFixed(1)}%`);\n  console.log(`   ❓ Missing Concepts: ${coverage.missingConcepts?.length || 0}`);\n  console.log(`   🔄 Needs Improvement: ${improvementNeeded}`);\n  if (improvementReasons.length > 0) {\n    console.log(`   📝 Reasons: ${improvementReasons.join('; ')}`);\n  }\n  \n  return {\n    success: true,\n    needsImprovement: improvementNeeded,\n    improvementReasons: improvementReasons,\n    \n    // Pass through original data\n    flashcards: flashcardData.flashcards,\n    count: flashcardData.flashcards.length,\n    sessionId: flashcardData.sessionId,\n    conceptsUsed: flashcardData.conceptsUsed,\n    conceptBreakdown: flashcardData.conceptBreakdown,\n    iteration: flashcardData.iteration,\n    maxIterations: flashcardData.maxIterations,\n    generationMethod: flashcardData.generationMethod,\n    \n    // Add comprehensive coverage analysis\n    coverageAnalysis: {\n      scores: scores,\n      coverageMetrics: {\n        highPriorityCoverage: highPriorityCoverage,\n        mediumPriorityCoverage: mediumPriorityCoverage,\n        overallCoverage: overallCoverage\n      },\n      cognitiveAnalysis: {\n        recallPercentage: recallPercentage,\n        higherOrderPercentage: higherOrderPercentage,\n        distribution: cognitive\n      },\n      missingConcepts: coverage.missingConcepts || [],\n      wellCoveredConcepts: coverage.wellCoveredConcepts || [],\n      recommendations: coverageAnalysis.recommendations || [],\n      aiAssessment: coverageAnalysis.improvementReason || 'No specific reason provided'\n    }\n  };\n  \n} catch (error) {\n  console.error('❌ Error parsing coverage analysis:', error.message);\n  console.error('Raw analysis response:', response);\n  \n  // Fallback to basic improvement logic\n  const basicNeedsImprovement = (\n    flashcardData.flashcards.length < 8 || \n    flashcardData.flashcards.length < conceptData.priorityBreakdown.high * 1.2\n  ) && flashcardData.iteration < flashcardData.maxIterations;\n  \n  return {\n    success: false,\n    error: error.message,\n    needsImprovement: basicNeedsImprovement,\n    improvementReasons: ['Coverage analysis failed - using basic logic'],\n    \n    // Pass through original data\n    flashcards: flashcardData.flashcards,\n    count: flashcardData.flashcards.length,\n    sessionId: flashcardData.sessionId,\n    conceptsUsed: flashcardData.conceptsUsed,\n    conceptBreakdown: flashcardData.conceptBreakdown,\n    iteration: flashcardData.iteration,\n    maxIterations: flashcardData.maxIterations,\n    generationMethod: flashcardData.generationMethod + '-fallback',\n    \n    coverageAnalysis: {\n      scores: { overall: 6, coverage: 6, priority: 6 },\n      fallback: true,\n      error: error.message\n    }\n  };\n}"
      },
      "id": "666d8bc3-cf9b-450d-b69b-6d8a8c23afc7",
      "name": "Parse Coverage Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -760,
        160
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.needsImprovement }}",
              "value2": true
            }
          ]
        }
      },
      "id": "9ad56c5c-de09-46fd-a9fe-b32e00c9f24b",
      "name": "Need Improvement?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -560,
        160
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-4.1-mini",
        "prompt": {
          "messages": [
            {
              "content": "=You are an expert educational content improver. Based on comprehensive concept coverage analysis, enhance the flashcards to address identified gaps and quality issues.\n\n**SPECIFIC IMPROVEMENT REQUIREMENTS:**\n\n🎯 **Coverage Analysis Results:**\n- Overall Score: {{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"scores\"][\"overall\"] }}/10\n- Priority Focus: {{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"scores\"][\"priority\"] }}/10\n- High Priority Coverage: {{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"coverageMetrics\"][\"highPriorityCoverage\"] }}%\n- Cognitive Complexity: {{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"cognitiveAnalysis\"][\"higherOrderPercentage\"] }}% higher-order thinking\n\n🔍 **Missing Concepts to Address:**\n{{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"missingConcepts\"].join(\", \") }}\n\n📊 **AI Recommendations:**\n{{ $node[\"Parse Coverage Analysis\"].json[\"coverageAnalysis\"][\"recommendations\"].join(\"\\n\") }}\n\n💡 **Improvement Reasons:**\n{{ $node[\"Parse Coverage Analysis\"].json[\"improvementReasons\"].join(\"; \") }}\n\n**ENHANCEMENT GUIDELINES:**\n1. **Address Missing Concepts**: Create flashcards for each missing high-priority concept\n2. **Increase Cognitive Complexity**: Add application, analysis, and synthesis questions\n3. **Improve Answer Depth**: Provide more comprehensive, contextual answers\n4. **Enhance Question Variety**: Use different question types (definition, comparison, application, problem-solving)\n5. **Strengthen Concept Integration**: Show relationships between concepts\n6. **Target Weak Areas**: Focus on concepts with poor coverage scores\n\n**COGNITIVE LEVEL TARGETS:**\n- Recall/Recognition: 30% (basic definitions, facts)\n- Understanding/Comprehension: 35% (explanations, examples)\n- Application: 25% (using concepts in scenarios)\n- Analysis/Evaluation: 10% (comparing, critiquing, problem-solving)\n\nGenerate 8-15 improved flashcards that specifically address the identified gaps. Return ONLY a JSON array:\n[{\"question\": \"Enhanced question addressing specific gap...\", \"answer\": \"Comprehensive answer with context and details...\"}, {\"question\": \"Application-level question...\", \"answer\": \"Detailed answer showing practical usage...\"}]\n\n**CURRENT FLASHCARDS TO IMPROVE:**\n{{ JSON.stringify($node[\"Parse Coverage Analysis\"].json[\"flashcards\"], null, 2) }}\n\n**COMPLETE CONCEPT REFERENCE:**\n{{ $node[\"Parse Concepts\"].json[\"conceptSummary\"] }}\n\nFocus on comprehensive coverage while maintaining educational quality and cognitive variety."
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "id": "479fd1ca-d7ab-41f5-bdfd-ac79fd8f4816",
      "name": "Improve Flashcards",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        -560,
        0
      ],
      "credentials": {
        "openAiApi": {
          "id": "KDqofqWJzHWJ0pPy",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse improved flashcards\nlet response;\ntry {\n  const input = $input.first().json;\n  \n  if (input.choices && input.choices[0] && input.choices[0].message) {\n    response = input.choices[0].message.content;\n  } else if (input.choices && input.choices[0] && input.choices[0].text) {\n    response = input.choices[0].text;\n  } else if (input.text) {\n    response = input.text;\n  } else if (input.message) {\n    response = input.message;\n  } else {\n    response = JSON.stringify(input);\n  }\n} catch (e) {\n  response = 'Error accessing response';\n}\n\n// Get data from Parse Coverage Analysis since we're now in the improvement loop\nconst previousData = $node[\"Parse Coverage Analysis\"].json; \nconst conceptData = $node[\"Parse Concepts\"].json;\n\ntry {\n  // Ensure response is always a string before processing\n  if (typeof response !== 'string') {\n    response = JSON.stringify(response);\n  }\n  \n  // Handle null or undefined responses\n  if (!response || response === 'null' || response === 'undefined') {\n    throw new Error('Empty or invalid response from AI');\n  }\n  \n  // Parse improved flashcards with enhanced cleaning\n  let cleanResponse = response\n    .replace(/```json\\s*/g, '')  // Remove ```json with any whitespace\n    .replace(/```\\s*/g, '')      // Remove ``` with any whitespace\n    .replace(/^json\\s*/g, '')    // Remove 'json' at start with whitespace\n    .trim();\n  \n  console.log(`🔍 Improved flashcards cleaned response preview: ${cleanResponse.substring(0, 100)}...`);\n  \n  let improvedFlashcards;\n  try {\n    improvedFlashcards = JSON.parse(cleanResponse);\n    console.log(`✅ Successfully parsed improved flashcards JSON directly`);\n  } catch (e) {\n    console.log(`⚠️ Direct improved flashcards parse failed: ${e.message}`);\n    \n    // Fallback: extract JSON array from text more robustly\n    const jsonMatch = cleanResponse.match(/\\[[\\s\\S]*\\]/);\n    if (jsonMatch) {\n      try {\n        improvedFlashcards = JSON.parse(jsonMatch[0]);\n        console.log(`✅ Successfully parsed improved flashcards JSON from regex match`);\n      } catch (parseError) {\n        throw new Error(`Failed to parse extracted improved flashcards JSON: ${parseError.message}`);\n      }\n    } else {\n      throw new Error('Could not parse improved flashcards - no valid JSON array found');\n    }\n  }\n  \n  if (!Array.isArray(improvedFlashcards)) {\n    throw new Error('Improved response is not an array');\n  }\n  \n  const validImproved = improvedFlashcards.filter(card => \n    card && \n    typeof card === 'object' &&\n    card.question && \n    card.answer &&\n    typeof card.question === 'string' && \n    typeof card.answer === 'string' &&\n    card.question.trim().length > 5 &&\n    card.answer.trim().length > 10\n  );\n  \n  if (validImproved.length === 0) {\n    throw new Error('No valid improved flashcards found');\n  }\n  \n  const currentIteration = (previousData.iteration || 1) + 1;\n  console.log(`🔄 Iteration ${currentIteration}: Improved to ${validImproved.length} flashcards (from ${conceptData.conceptCount} concepts)`);\n  \n  return {\n    success: true,\n    flashcards: validImproved,\n    count: validImproved.length,\n    sessionId: previousData.sessionId,\n    conceptsUsed: conceptData.conceptCount,\n    conceptBreakdown: conceptData.priorityBreakdown,\n    improved: true,\n    iteration: currentIteration,\n    maxIterations: previousData.maxIterations,\n    generationMethod: 'concept-based-improved'\n  };\n  \n} catch (error) {\n  console.error(`❌ Error parsing improved flashcards:`, error.message);\n  \n  // Fall back to original flashcards\n  return {\n    success: false,\n    error: error.message,\n    flashcards: previousData.flashcards,\n    count: previousData.flashcards.length,\n    sessionId: previousData.sessionId,\n    conceptsUsed: conceptData.conceptCount,\n    conceptBreakdown: conceptData.priorityBreakdown,\n    improved: false,\n    generationMethod: 'concept-based-fallback'\n  };\n}"
      },
      "id": "cc1b77b3-eb88-40b1-81ed-99d15db3cc98",
      "name": "Parse Improvements",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -360,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare final response with concept analysis\nlet inputData;\n\n// Check which path we came from (improvement or direct)\nif ($input.first().json.improved !== undefined) {\n  // Came from improvement path\n  inputData = $input.first().json;\n} else {\n  // Came directly from parse flashcards\n  inputData = $input.first().json;\n}\n\nconst finalResponse = {\n  success: true,\n  flashcards: inputData.flashcards,\n  metadata: {\n    totalCards: inputData.flashcards.length,\n    sessionId: inputData.sessionId,\n    generatedAt: new Date().toISOString(),\n    generationMethod: inputData.generationMethod || 'concept-based',\n    improved: inputData.improved || false,\n    processingComplete: true,\n    \n    // Concept analysis metadata\n    conceptAnalysis: {\n      totalConcepts: inputData.conceptsUsed,\n      priorityBreakdown: inputData.conceptBreakdown,\n      coverageRatio: (inputData.flashcards.length / inputData.conceptsUsed).toFixed(2),\n      \n      // Comprehensive coverage analysis (if available)\n      qualityScores: inputData.coverageAnalysis?.scores || {},\n      coverageMetrics: inputData.coverageAnalysis?.coverageMetrics || {},\n      cognitiveAnalysis: inputData.coverageAnalysis?.cognitiveAnalysis || {},\n      missingConcepts: inputData.coverageAnalysis?.missingConcepts || [],\n      recommendations: inputData.coverageAnalysis?.recommendations || [],\n      improvementReasons: inputData.improvementReasons || []\n    }\n  }\n};\n\n// Add flags for different scenarios\nif (inputData.fallback) {\n  finalResponse.metadata.fallback = true;\n  finalResponse.metadata.note = \"Used fallback flashcards due to parsing issues\";\n}\n\nif (inputData.error) {\n  finalResponse.metadata.warnings = [inputData.error];\n}\n\nif (!inputData.success) {\n  finalResponse.metadata.processingIssues = true;\n}\n\n// Enhanced logging with concept information\nconsole.log(`🎉 CONCEPT-BASED FLASHCARD GENERATION COMPLETE!`);\nconsole.log(`   📚 Generated: ${inputData.flashcards.length} flashcards`);\nconsole.log(`   🧠 From Concepts: ${inputData.conceptsUsed}`);\nconsole.log(`   📊 Priority Breakdown: High(${inputData.conceptBreakdown?.high || 0}), Medium(${inputData.conceptBreakdown?.medium || 0}), Low(${inputData.conceptBreakdown?.low || 0})`);\nconsole.log(`   📋 Session: ${inputData.sessionId}`);\nconsole.log(`   🔄 Improved: ${inputData.improved || false}`);\nconsole.log(`   ⚡ Method: ${inputData.generationMethod}`);\n\nreturn finalResponse;"
      },
      "id": "1e4dae7b-29dc-413d-9615-493c1af8d60a",
      "name": "Final Response Builder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -360,
        160
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json, null, 2) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Methods",
                "value": "POST, OPTIONS"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type, Authorization"
              }
            ]
          }
        }
      },
      "id": "f77a3359-4c1a-4d8c-97c8-05d797b1ef5a",
      "name": "Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -160,
        160
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Initialize Variables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Variables": {
      "main": [
        [
          {
            "node": "Extract Concepts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Concepts": {
      "main": [
        [
          {
            "node": "Parse Concepts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Concepts": {
      "main": [
        [
          {
            "node": "Generate Flashcards",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Flashcards": {
      "main": [
        [
          {
            "node": "Parse Flashcards",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Flashcards": {
      "main": [
        [
          {
            "node": "Select Flashcards Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Select Flashcards Data": {
      "main": [
        [
          {
            "node": "Concept Coverage Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Concept Coverage Analysis": {
      "main": [
        [
          {
            "node": "Parse Coverage Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Coverage Analysis": {
      "main": [
        [
          {
            "node": "Need Improvement?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need Improvement?": {
      "main": [
        [
          {
            "node": "Improve Flashcards",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Final Response Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Improve Flashcards": {
      "main": [
        [
          {
            "node": "Parse Improvements",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Improvements": {
      "main": [
        [
          {
            "node": "Select Flashcards Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Final Response Builder": {
      "main": [
        [
          {
            "node": "Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "69c4c21d-080c-40b9-8cae-fb7a9a28621a",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "304854bba464753094d47904a80cc1b97958d7982642a8841539c1e44d30ce2d"
  },
  "id": "285dLteF58gruqYD",
  "tags": [
    {
      "createdAt": "2025-07-02T22:09:42.701Z",
      "updatedAt": "2025-07-02T22:09:42.701Z",
      "id": "Ai3tR3tnqZS9aKqB",
      "name": "education"
    },
    {
      "createdAt": "2025-07-02T22:09:42.732Z",
      "updatedAt": "2025-07-02T22:09:42.732Z",
      "id": "cnJbCEFgHf6YuA2e",
      "name": "ai"
    },
    {
      "createdAt": "2025-07-02T22:09:42.677Z",
      "updatedAt": "2025-07-02T22:09:42.677Z",
      "id": "foaAUbmIIbF2izYw",
      "name": "cognify"
    },
    {
      "name": "adaptive",
      "id": "yaFQDsDuwGLPusD7",
      "createdAt": "2025-07-03T01:17:31.760Z",
      "updatedAt": "2025-07-03T01:17:31.760Z"
    }
  ]
}